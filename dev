#!/usr/bin/env bash

function check_command {
  local command=$1
  command ${command} >/dev/null 2>&1
  if [ "$?" != "0" ]; then
    echo "⨯ ${command} not found"
    echo "Please install ${command}!"
    exit 1
  fi
  echo "✓ ${command} found"
}

function check_requirements {
  check_command "docker"
  check_command "mutagen"
}

function startup {
  echo "Starting stack. This might take a while on the first run."
  mutagen project start || mutagen project resume
}

function attach_to_web {
  echo "Attaching to the application container. Use Ctrl+p Ctrl+q to leave."
  docker attach backoffice_web_1
}

function tail_logs {
  docker-compose logs --follow
}

function shutdown {
  echo "Shutting down..."
  mutagen project pause
  echo "done"
}

function run_start {
  check_requirements
  startup
  attach_to_web
}

function run_stop {
  shutdown
}

function run_rebuild {
  mutagen project terminate
  run_start
}

function run_clean {
  mutagen project terminate
  rm -fr _build deps assets/node_modules
  docker-compose down --rmi=all --volumes
}

function run_update_translations {
  run_command web "mix do gettext.extract, gettext.merge priv/gettext --locale de"
  echo "Extracted and updated translation strings. Please translate."
}

function run_tests {
  local command="mix test $@"
  run_command web ${command}
}

function run_yarn {
  local command="cd assets && yarn $@"
  run_command web ${command}
}

function run_command {
  local container_name=${1}
  local command="${@:2}"
  docker-compose exec ${container_name} bash -c "${command}"
}

function print_usage {
  echo "Usage: ./dev [command] [args]"
}

function show_help {
  cat  << EOF
The following commands are supported:

./dev start                 # Start the development stack
./dev stop                  # Stop the development stack
./dev rebuild               # Rebuild the images and restart the development stack
./dev reset                 # Reset the stack (including volumes and images)
./dev update_translations   # Run the (Elixir) tests
./dev test                  # Run the (Elixir) tests
./dev yarn                  # Run a Yarn command
./dev execute               # Run arbitrary command in a container

To get information about a single command use ./dev [command] --help
EOF
}

function maybe_show_command_help {
  if [ "${1}" == "--help" ]; then
    return
  fi
  if [ "${2}" != "--help" ]; then
    return
  fi
  case ${command} in
    "start"|"s")
      print_help_for_start
      ;;
    "stop"|"st")
      print_help_for_stop
      ;;
    "rebuild"|"rb")
      print_help_for_rebuild
      ;;
    "reset"|"rs")
      print_help_for_reset
      ;;
    "translations.update"|"tu")
      print_help_for_update_translations
      ;;
    "test"|"t")
      print_help_for_test
      ;;
    "yarn"|"y")
      print_help_for_yarn
      ;;
    "execute"|"e")
      print_help_for_execute
      ;;
    *) echo "No help found for '${command}'"
  esac
  exit 0
}

function print_help_for_start {
  cat << EOF
# start

shortcut: s

The 'start' command checks if the required tools (Docker, Mutagen) are available.
If so it will check and create or load the images needed for the application.
It starts the application stack with all containers and opens the logs.
Stop the command with ctrl-c. This will stop the stack.
EOF
}

function print_help_for_stop {
  cat << EOF
# stop

shortcut: st

The 'stop' command will stop the stack. All data and containers will be preserved.
EOF
}

function print_help_for_rebuild {
  cat << EOF
# rebuild

shortcut: rb

The 'rebuild' command will tear down and rebuild the containers.
The volumes and images will be preserved.
EOF
}

function print_help_for_reset {
  cat << EOF
# reset

shortcut: rs

The 'reset' command tears down the application and removes all built images and volumes.
This is useful to start over.
EOF
}

function print_help_for_update_translations {
  cat << EOF
# translations.update

shortcut: tu

The 'update_translations' command extracts and updates the application translations.
EOF
}

function print_help_for_test {
  cat << EOF
# test [test_file_path]

shortcut: t

The 'test' command runs the test suite.
To run single tests the path can be passed as an argument.
EOF
}

function print_help_for_yarn {
  cat << EOF
# yarn [args]

shortcut: y

The 'yarn' command runs Yarn commands within the web container.
EOF
}

function print_help_for_execute {
  cat << EOF
# execute [container_name] [args]

shortcut: e

The 'execute' command runs arbitrary commands in the given container.
F.e. you can run './dev execute web "cd assets && yarn add my_dep -D"' to add a javascript library.
EOF
}

function main {
  local command=${1}
  local args="${@:2}"
  maybe_show_command_help ${command} ${args}
  case ${command} in
    "--help")
      show_help
      ;;
    "start"|"s")
      run_start
      ;;
    "stop"|"st")
      run_stop
      ;;
    "rebuild"|"rb")
      run_rebuild
      ;;
    "reset"|"rs")
      run_clean
      run_start
      ;;
    "translations.update"|"tu")
      run_update_translations
      ;;
    "test"|"t")
      run_tests ${args}
      ;;
    "yarn"|"y")
      run_yarn ${args}
      ;;
    "execute"|"e")
      run_command ${args}
      ;;
    *) print_usage; echo; show_help
  esac
}

main $@
